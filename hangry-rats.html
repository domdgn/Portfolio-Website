<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Group Game Project Y1S1</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style/style.css">
    <link rel="stylesheet" href="styles/atom-one-dark.min.css">
    <script src="/script/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
    <header>
        <nav>
            <a href="#" class="logo"><em>DD</em></a>
            <div class="nav-links">
                <a href="/index.html">Home</a>
                <a href="/index.html#projects">Projects</a>
                <a href="/about.html">About</a>
                <a href="/assets/CV - Dominic Duggan.pdf">CV</a>
            </div>
        </nav>
    </header>

    <main style="max-width: 1200px; margin: 80px auto; padding: 20px;">
        <article class="project-article">
            <h1>Hangry Rats - Group Game Project</h1>

            <section>
                <h2 class="overview">Overview</h2>
                <p><strong>2D Puzzle-Platformer</strong></p>
                <p><span>Date Started:</span> 7th November 2024</p>
                <p><span>My Role:</span> Developer</p>
                <p><span>Software Used:</span> Unity, C#</p>
                <img src="assets/rats/final_placeholder.jpg" alt="Project Overview" class="finalimg">
            </section>
            <br>
            <h1>Section 1 | Prototype</h1>
            <section>
                <h2>1.1 Introduction & Goal</h2>
                <p>This is a Group Game Project made in Year 1, Semester 1. You play as a chef with the goal of collecting as many ingredients as you can before the enemy rats take them.You can throw cheese to distract the rats and activate buttons.</p>
            </section>
<br><br>
            <section>
                <h2>1.2 Concept and Inspiration</h2>
                <p>As a team we initally came together and brainstormed ideas for our project, the only restriction in the brief was that it needs to be rated at or below <span>PEGI 12</span>.</p>
                <br>
                <p>We assessed the skills of everyone in the group, and first decided on what art style to produce. Due to the majority of the artists having proficiency in 2D art, we decided that the best option to prevent the risk of not being able to achieve the planned scope was to create a 2D game in a pixel art style.</p>
                <br>
                <p>Then, we worked to define what the concept of the game would be. We were comfortable with restricting ourselves to the art style,  and we used <span>Miro</span> to organise our ideas and come up with the final concept of a puzzle platformer themed around cooking. Our first concepts involved the rat enemies being killable, perhaps with a similar mechanic to that of the goombas in Super Mario Bros. 
                    <br><br>
                    However, we deemed animal cruelty as not fitting the brief, and instead decided on a fun and engaging puzzle-platformer game, where instead of being able to crush the rats, you instead can distract them, and you need to do this to activate buttons to progress.
                    <br><br>
                    We designed the concept of the game using a whiteboard, <span>[1.2.1]</span> and settled confidently on our project idea.
                </p>


                <img src="assets/rats/whiteboard.jpg" alt="Whiteboard Notes 2.1" style="width: 500px; border-radius: 8px; margin: 20px 0;">
                <span class="RefNum">1.2.1</span>
                <br>
                <p>After spending time on this, as a team we quickly pulled together some reference art and developed what the setting for our game was going to be like:</p>
                <div class="image-group">
                    <figure>
                        <img src="assets/rats/Ref/ref_art.png" alt="Reference 1">
                        <div class="RefNum">1.2.2</div>
                    </figure>
                    <figure>
                        <img src="assets/rats/Ref/ref2.jpg" alt="Reference 2">
                        <div class="RefNum">1.2.3</div>
                    </figure>
                    <figure>
                        <img src="assets/rats/Ref/ref3.jpg" alt="Reference 3">
                        <div class="RefNum">1.2.4</div>
                    </figure>
                </div>
                <p>We then developed my ideas into my <strong>final setting concept</strong>: various locations, beginning first in a small, artificially lit alleyway, and the game progresses into a brighter, more lively city centre as levels go on.</p>
            </section>
<br><br>
            <section>
                <h2>1.3 Tools and Software</h2>

                <h3>Unity</h3>
                <p>Myself and Dan Ballem (the other developer on the project) were both already familiar with the 2D development tools in Unity, therefore, we decided it was best - and within scope - to develop the prototype for our game with such tools.</p>
                
                <h3>Miro</h3>
                <p>Miro is an online interactive whiteboard/note-taking app, used widely in industry and we chose to use it with this project, to gather ideas and inspiration in a manageable and shareable format, ideal for showing how and why we developed our ideas.</p>

                <h3>Aseprite & Libresprite</h3>
                <p>The artists used mainly Aseprite and Libresprite. These are both pixel art programs, Libresprite is a free fork of Aseprite, and they are intercompatible.</p>
            </section>
<br><br>
            <section>
                <h2>1.4 Programming</h2>
                
                <h3>My Responsibilities</h3>
                <p>As a team we had already planned out our weekly goals for the 6 weeks that this project will go on for, but we had to decide which tasks were whose responsibility as developers. We agreed that I was to develop the character controller, 
                    ingredient pickup system, button & door mechanics, the cheese throwing, and the main menu/UI.  Dan Ballem took responsibility for the enemy AI, importing all the art assets, making them function, refining existing mechanics and scripts, and creating the levels.</p>
                
<pre style="background: #1e293b; padding: 20px; border-radius: 8px; margin: 40px 0; white-space: pre-wrap;">
    <h3>Timeline Overview:</h3>
    <b>Week 1: Conceptualisation and Game Design Document</b>
    -	Research, concept art
    -	Early plans for level layouts
    <b>Week 2: Initial prototype development (basic mechanics) & Art assets creation</b>
    -	Character controller, character sprites, basic enemy AI, Ingredient pickup
    <b>Week 3: Refining mechanics & level layout planning/implementation</b>
    -	Improving already existing mechanics
    -	Ingredient spawning + enemy spawning
    -	Buttons & Doors for puzzle element
    -	Creation of conceptualised levels
    -	Refining game loop
    <b>Week 4: Refining Prototype & Refining art</b>
    -	Implementation of pause/menu screen & UI
    -	Win condition
    -	Continued design work on art and UI
    <b>Week 5: Feedback integration and polishing the prototype</b>
    -	Continued refining of mechanics
    -	Fixing of critical bugs
    -	Get the game into a playable state
    <b>Week 6: Final presentation and individual reflections</b>
</pre>
                
<h3 class="responsibilities">- Character Controller -</h3>
<br>
                <p>The first thing I did to ensure that a functional prototype could be delivered in time was to create a demo scene, and develop the character controller. This was to allow for a minimum viable product to be created as fast as possible, by giving the other developer a premade scene to allow for easy implementation.
                    <br>
                    My first iteration of the character controller was extremely simple: <span>[1.4.1]</span>
                </p>
<pre>
<code class="language-csharp">    private void FixedUpdate()
    {
        HandleMovement();
        HandleJumping();
    }
    private void HandleMovement()
    {
        float horizontalInput = Input.GetAxis("Horizontal");
        rb.velocity = new Vector2(horizontalInput * speed, rb.velocity.y);
    }
    private void HandleJumping()
    {
        if (Input.GetKeyDown(KeyCode.Space) || Input.GetKeyDown(KeyCode.UpArrow) && isGrounded)
        {
            rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);
        }
    }
</code></pre>
<br><br>
<p>I then improved this by adding better feeling jumps, I was inspired by an approach that many platformers take, by allowing the player to make smaller, finer jumps when tapping jump, and larger jumps when holding it. I implemented this by adding extra downward force to the player when falling and reducing upward force when releasing the jump button early. <br>This creates snappier, more responsive and better-feeling jump mechanics by adjusting gravity dynamically.
<br><br>AdjustGravity() runs in FixedUpdate() due to rigidbody physics calculations
</p>

<pre>
    <code class="language-csharp">    private void AdjustGravity()
        {
            if (rb.velocity.y < 0)
            {
                rb.velocity += Vector2.up * Physics2D.gravity.y * (fallMultiplier - 1) * Time.fixedDeltaTime;
            }
            else if (rb.velocity.y > 0 && !Input.GetKeyDown(KeyCode.Space) && !Input.GetKeyDown(KeyCode.UpArrow))
            {
                rb.velocity += Vector2.up * Physics2D.gravity.y * (lowJumpMultiplier - 1) * Time.fixedDeltaTime;
            }
        }
</code></pre>

<img src="assets/rats/charcontrollerdemo.gif" alt="Controller Demo 4.1" style="width: 500px; border-radius: 8px; margin: 20px 0;">
<span class="RefNum">1.4.1</span>

<p>To make this work, I created a prototype player object, which was a 2D capsule sprite, with a 2D box collider (to prevent falling off of corners). I gave this player the tag "Player" and put it on a new layer named "Player" <br>
    this is so that we could control what collisions do or do not interact with the player, and how the interactions function. The capsule was given a Rigidbody 2D component, a custom 'no friction' physics material, and the PlayerController.cs script. <br>
    Ground checking is performed by 
</p>
<pre><code class="language-csharp">isGrounded = Physics2D.OverlapCircle(groundCheck.position, groundCheckRadius, groundLayer);</code></pre>
<br>
<p>so I created a child empty named GroundCheck at the player's 'feet' and in the inspector, linked everything up <span>[1.4.2]</span>. I also put all 'ground' gameObjects into a new layer called Ground, to ensure the collisions only worked between the player and ground.</p>
<img src="assets/rats/inspectorPlayer.png" alt="Controller Demo 4.1" style="width: 500px; border-radius: 8px; margin: 20px 0;">
<span class="RefNum">1.4.2</span>
<br>
<p>I turned this player into a prefab, to ensure that it can be used in multiple scenes, but all edits affect all instances of the player.</p>
<br>
<h3 class="responsibilities">- Item Pickup -</h3>
<br>
<p> Due to previous experience with a PowerUp Picku system in my Top-Down 3D Shooter project, I was very confident with making a working ingredient pickup mechanic.
    Pickups are handled by PickUpController.cs, which serves as a manager for the pickup system using the Singleton pattern. It tracks the number of collectibles picked up,
    persists between scenes via DontDestroyOnLoad, and communicates with the UI system to display the current count. The Singleton implementation ensures only one instance exists, preventing duplicate tracking and maintaining consistent state across the game.
</p>
<pre>
    <code class="language-csharp">public static PickUpController Instance { get; private set; }

private void Awake()
{
    if (Instance == null)
    {
        Instance = this;
        DontDestroyOnLoad(gameObject);
    }
    else
    {
        Destroy(gameObject);
    }
}

private void Start()
{
    ResetPickups();
}

public void CollectPickup()
{
    pickUpCount++;
    UpdateUI();
}
</code></pre>
<br>
<p>To demo this, I made a SamplePickup prefab with tag "PickUp" on layer "PickUps". This object has a Circle Collider 2D component, with Is Trigger set to true.
    <br>
    In the Player's collision script, the CollectPickup() function is called if the player enters a trigger of object with tag "PickUp", increasing the count of pickups by 1, and updating UI.
    Then, the other gameObject (in this case, the pickup) is destroyed.
    <br><br> 
    It may have been better to simply disable the gameObject, however this is only a prototype, and for our current levels, there is never a need to re-enable a pickup.
    Only the Player layer can collide with the PickUps layer, preventing any unintentional triggers.
    <br><br>
    This system is seen functioning in <span>[1.4.1]</span>
</p>





<br>
            <section>
                <h2>Shading, Texturing and UV Mapping</h2>
                <p>Discuss the texturing process, including how you unwrapped the UVs and applied textures to the models.</p>
            </section>
<br>
            <section>
                <h2>Lighting and Rendering</h2>
                <p>Outline the lighting setup and rendering process. Mention any techniques used to enhance the visual quality of the environment.</p>
            </section>
<br>
            <section>
                <h2>Challenges Faced</h2>
                <p>Describe any challenges encountered during the modeling process and how they were overcome.</p>
            </section>
<br>
            <section>
                <h2>Final Thoughts</h2>
                <p>Provide a concluding section with your reflections on the project. Mention what you learned and how it will influence future projects.</p>
            </section>
<br>
            <section class="references">
                <h3>References</h3>
                <p>refs and stuffs</p>
            </section>
        </article>
    </main>
</body>
</html>