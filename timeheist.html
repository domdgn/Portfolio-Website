<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Heist Y1S2</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style/style.css">
    <link rel="stylesheet" href="styles/atom-one-dark.min.css">
    <link rel="icon" href="images/favicon.ico">
    <script src="script/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
    <header>
        <nav>
            <a href="index.html" class="logo">
                <svg width="32" height="32" viewBox="0 0 62 57" xmlns="http://www.w3.org/2000/svg">
                    <g>
                        <rect width="10" height="57" fill="#f87338"/>
                        <path d="M13,52h20c12.5,0,24-10.25,24-23.5S46.5,5,33,5H13" fill="none" stroke="#f87338" stroke-miterlimit="10" stroke-width="10"/>
                        <path d="M13,39h18.64c6.88,0,12.46-4,12.46-10.63s-5.58-10.37-12.46-10.37H13" fill="none" stroke="#f87338" stroke-miterlimit="10" stroke-width="10"/>
                    </g>
                </svg>
            </a>
            <div class="nav-links">
                <a href="index.html">Home</a>
                <a href="index.html#projects">Projects</a>
                <a href="about.html">About</a>
                <a href="assets/CV - Dominic Duggan.pdf">CV</a>
            </div>
        </nav>
    </header>

    <main style="max-width: 1200px; margin: 80px auto; padding: 20px;">
        <article class="project-article">
            <br>
            <h1>Time Heist - Group VR Game Project</h1>

            <section>
                <h2 class="overview">Overview</h2>
                <p><strong>VR Interactive Game</strong></p>
                <p><span>Date Started:</span> April 2025</p>
                <p><span>My Role:</span> Developer</p>
                <p><span>Software Used:</span> Unity, C#</p>
                <img src="images/placeholder.jpg" alt="Project Overview" class="finalimg">
                 <br>
                <!-- <iframe style="box-shadow: 0 10px 50px #010d13; border-radius: 8px;" frameborder="0" src="https://itch.io/embed-upload/13561435?color=333333" allowfullscreen="" width="360" height="660"><a href="https://domdgn.itch.io/cats-and-frogs">Play Cats and Frogs on itch.io</a></iframe> -->
                <h3><a href="https://github.com/domdgn/VR-Dungeon-Game/releases/download/exhibition-demo/TimeHeistExhibitionBuild.apk">Download APK (for Meta Quest)</a></h3>
                <span><a href="https://github.com/domdgn/VR-Dungeon-Game/">GitHub</a></span>
            </section>

            <br><br>
            <h1>Section 1 | Introduction</h1>
            <section>
                <h2>1.1 Brief</h2>
                <p>This is a Group Game Project made in Year 1, Semester 2.
                    <br><br>
                    The goal is to develop a presentable, playable prototype of a game. The brief was as follows: 
                    <br>
                    <b style="color: rgb(101, 141, 9);">"Working in groups, create and develop a game that takes advantage of immersive and interactive technologies."</b>
                    <br><br>
                    My role in this project was as <span>Developer</span>.
                    <br>
                    I worked in a team of 3 Developers and 3 Artists/Designers. However we all concepted our project as a group.
                </p>
            </section>
<br><br>
            <section>
                <h2>1.2 Concept and Inspiration</h2>
                <p>As a class, we all pitched ideas for the projects, which were voted on, and the top votes were then developed by seperate groups. I had the idea of creating
                    a game that is similar to/inspired by games such as <span>R.E.P.O.</span> and <span>Lethal Company</span>, involving procedurally generated levels which contain loot, and your goal is to collect the highest value of loot.
                </p>
                <br>
                <p>
                    My idea was highly voted, and after we picked our groups, we had a meeting to solidify our objective and what the game will be.
                </p>
<pre style="background: #1e293b; padding: 20px; border-radius: 8px; margin: 40px 0; white-space: pre-wrap;">
<h3>Group Project 3 – Meeting 1</h3>

<b>Key Points:</b>
- Testing the team on VR, need a benchmark for motion sickness.
- Making the game colorblind friendly:
    • Protanomaly, based on Dom’s colorblindness.
    • Then can build off of that and make normal color vision.

<b>Gameplay Loop:</b>
- Being chased by a monster, collect items of value to hit a quota.
- Collect items of value, then solve puzzles to leave.
- Timer on each level, collect items of value before the timer runs out.
- Backpack system, most items can be stored aside from larger items.
- Weight system, carrying too much can slow you down.
- Oil lamp for lighting, can be stored on the hip.

<b>Design Choices:</b>
- Cave-in at <i>pyramid/temple</i>, collect items and leave before cave-in.
- Could make stylized <i>Tomb Raider</i> design, more polygonal.
- However, could be bad for UX as it can be <b>bad</b> on the eyes.
- British Empire setting, <b>grave robbing pyramids for museums</b>.
- Easter egg items, pics of devs on different items.

<b>Planned Features:</b>
- <b>Shop will be added on the 2nd iteration:</b>
    • Item shop for purchasing backpack slots, speed, maps, etc.

<b>Extra Tasks:</b>
- Hand textures.
- Extra level.
- Animated wall insects.
</pre>

                <p>As per this meeting, we developed the core setting and goal for our game: <i>procedurally generated pyramids, where you enter, collect loot, and leave before time runs out and the pyramid collapses.</i>
                <br><br>We then collected both visual references and references for the procedural generation algorithm which I would be developing, some of which are shown below.
                </p>
                <div class="image-group">
                    <figure>
                        <img src="assets/timeheist/refskull.png" alt="Reference 1">
                        <span class="RefNum"><a href="#references">1.2.1</a></span>
                    </figure>
                    <figure>
                        <img src="assets/timeheist/procgenref.webp" alt="Reference 2">
                        <span class="RefNum"><a href="#references">1.2.2</a></span>
                    </figure>
                    <figure>
                        <img src="assets/timeheist/repopresskit.png" alt="Reference 3">
                        <span class="RefNum"><a href="#references">1.2.3</a></span>
                    </figure>
                    <figure>
                        <img src="assets/timeheist/wanderer.jpg" alt="Reference 3">
                        <span class="RefNum"><a href="#references">1.2.4</a></span>
                    </figure>
                </div>
                <br>
                <p>The project lead created a Gantt chart to organise what we would be doing for the duration of the project.</p>
                <img src="assets/timeheist/image.png" style="width: 750px;">
            </section>
<br><br>
            <section>
                <h2>1.3 Tools and Software</h2>

                <h3>Unity</h3>
                <p>Unity is the game engine we chose to use, due to its familiarity and stength of 2D tools and workflow</p>
                
                <h3>Discord</h3>
                <p>Discord is an online instant messaging and group chat application, this is what we used mainly to communicate and share ideas</p>
            </section>
<br><br><br>
            <h1>Section 2 | Programming</h1>
            <section>
                <h2>2.1 Room Generation</h2>
                <img src="assets/timeheist/key.png" style="width: 750px;">
                <p>Before I began programming, I setup a new Unity project, installed all the necessary packages and created a <span>GitHub</span> repository to use as my version control software.
                This Unity project was <b>completely separate</b> to the main <span>Time Heist</span> project, as I wanted the generator to be available separately on its own (V1 available on my GitHub).
                </p>
                <br>
                <h3>Goal</h3>
                <p>The goal for the procedural generation is relatively simple: have multiple prefabs for rooms and hallways, which connect together seamlessly to generate an interesting level.
                    <br><br>
                    To achieve this, I researched many different procedural generation algorithms, some of which involved <span>pathfinding</span>, and some of which involved <span>randomness</span>.
                    <br>
                    At the end, I found a video tutorial about a procedural dungeon system in <span>Unreal Engine 5</span> by <a href="https://www.youtube.com/@REE-Animation">REE Animation</a>, which seemed to be a good base for what I needed. <br> However, our game is developed
                    in <span>Unity</span>, so I couldn't simply take and re-use the original code, I had to learn how the generation worked, and write my own <span>C#</span> code which worked around these principles.
                </p>
                <br>
    <div style="position: relative; overflow: hidden; border-radius: 8px;">
        <iframe src="https://www.youtube.com/embed/4ddbnQIuwAM" 
                frameborder="0" 
                allowfullscreen 
                style="width: 600px; height: 338px;">
        </iframe>
    </div>
    <br>
    <span class="RefNum"><a href="#references">2.1.1</a></span>
    <br>
    <p>
        Due to information from both this video and others, I decided that I want my generator to <span>randomly</span> place room prefabs connected to manually defined 'EntryPoints' in a convincingly seamless manner. 
        <br><br>
        As such, my generator follows this basic order of operations:
        <br><br>
        The <span>DungeonGenerator</span> script in Unity procedurally generates a dungeon layout by starting from a predefined 
  <span>startRoom</span> and expanding it with rooms and hallways from a selected <span>LevelSO</span> Scriptable Object. 
  It randomly picks a level configuration, then repeatedly places new room prefabs by aligning their unconnected entry 
  points with those of existing rooms. Proper alignment is handled using rotation and position offsets, while overlap is 
  checked using colliders to ensure valid placement. Successfully placed rooms are added to the dungeon until a maximum 
  room count is reached. Once generation is complete, unconnected entry points are sealed with closed doors, and items 
  are spawned using an attached <span>ItemSpawner</span> component. <span>UnityEvents</span> are used to signal the start 
  and completion of dungeon generation, allowing for easy integration with other systems.
    </p>
    <img src="assets/timeheist/entry.webp" style="width: 500px;">
    <p>Entry Points are placed manually in the Unity Editor, with the <span>Local Z-axis</span> always pointing outwards to ensure correct rotation.</p>
    <br><br>
    <h3 class="responsibilities">- Dungeon Initialisation -</h3>
    <br>
    <p>Handles the initial setup of the dungeon by selecting a random level configuration, clearing previous data, and starting the asynchronous dungeon generation process. Utilises UnityEvents to notify when generation starts and prevents overlapping generation calls.</p>
<pre>
<code class="language-csharp">public void ResetDungeon()
{
    if (activelyGenerating == false)
    {
        activelyGenerating = true;
        onGenerationStarted.Invoke();

        ClearLevel();
        itemSpawner.DeleteAllItems();

        if (levels.Count > 0)
        {
            levelData = levels[Random.Range(0, levels.Count)];
            Debug.Log(levelData.levelName + "level selected");
        }

        SetUpLevelData(levelData);
        StartCoroutine(GenerateDungeon());
    }
    else Debug.LogWarning("Dungeon is already generating!");
}
</code>
</pre>
    <br>
    <h3 class="responsibilities">- Room Placement -</h3>
    <br>
    <p>Controls the core logic for placing new rooms or hallways by selecting appropriate prefabs based on randomised probabilities, then prepares to connect these new rooms to existing ones through available entry points.</p>
<pre>
<code class="language-csharp">IEnumerator PlaceNextRoom()
{
    GameObject sourceRoom = placedRooms[Random.Range(0, placedRooms.Count)];

    if (levelData == null)
    {
        roomPrefabToPlace = masterPrefab;
    }
    else
    {
        if (Random.value < currentHallwayChance)
        {
            roomPrefabToPlace = levelData.hallwayPrefabs[Random.Range(0, levelData.hallwayPrefabs.Count)];
            currentHallwayChance = hallwayChance * sequentialHallwayChanceMulti;
        }
        else
        {
            roomPrefabToPlace = levelData.roomPrefabs[Random.Range(0, levelData.roomPrefabs.Count)];
            currentHallwayChance = hallwayChance;
        }
    }

    // ...connection and transform alignment logic
}
</code>
</pre>
    <br>
    <h3 class="responsibilities">- Room Alignment -</h3>
    <br>
    <p>Aligns the new room to the existing dungeon layout by matching entry points’ positions and rotations, then checks for spatial overlaps to ensure no rooms collide before finalising placement.</p>
<pre>
<code class="language-csharp">Quaternion rotation = Quaternion.FromToRotation(selectedNewEntry.forward, -selectedSourceEntry.forward);
roomToSpawn.transform.rotation = rotation;

FixUpsideDown(roomToSpawn);

Vector3 entryGlobalPos = roomToSpawn.transform.TransformPoint(selectedNewEntry.localPosition);
Vector3 offset = selectedSourceEntry.position - entryGlobalPos;
roomToSpawn.transform.position = offset;

if (IsRoomOverlapping(roomToSpawn))
{
    Destroy(roomToSpawn);
    yield return null;
}
</code>
</pre>
<br>
                <video autoplay loop muted playsinline style="width: 800px; border-radius: 8px;">
                    <source src="assets/timeheist/gendemo.webm" type="video/webm">
                    Your browser does not support the video tag.
                </video>
<br>
<h3>Issues & Fixes </h3>
<p>
    Whilst my code results in something I am very happy with, and works great for this project, there were some issues I encountered. <br><br> For example,
    I noticed that occasionally, rooms would spawn <i>upside down</i>. <br> I could not figure out what was going wrong in the room rotation logic to cuase this, <br><br>Therefore, I fixed this by adding the <span>FixUpsideDown</span>(GameObject roomToSpawn) check in the placement logic. <br><br>
    This detects if a room is upside down by checking if the room's <span>Local Up Vector</span> is aligned with the <span>Global Down Vector</span> by using a <span>Dot Product</span> threshold, and if so, it flips the room by rotating it 180 degrees on the local Z-axis. <br><br> I also encountered an issue where rooms would overlap (this can be seen in the demo gif above, as it is from an older version.) <br><br>
    I fixed this by implementing a collision detection system in the <span>IsRoomOverlapping</span>(GameObject room) method. <br><br> This uses Unity's <span>Physics.OverlapBox</span> function to check whether the newly spawned room's bounds (scaled slightly smaller to prevent false-positives) intersect with any trigger colliders on the <span>Room Layer</span>, and if so it is destroyed and re-attempted.
</p>
</section>
<br><br>
<section>
<h2>2.2 Game Logic</h2>
<p>I had the responsibility of programming the game logic. This is mostly controlled in <span>GameManager.cs</span>, with key parts such as handling of currency and UI to their respective managers.
<br><br>
The <span>GameManager</span> handles the game's lifecycle, coordinating dungeon generation, game start/end conditions, player presence at the start zone, and timing logic. It connects to other components like <span>DungeonGenerator</span>, <span>StartTrigger</span>, and <span>Timer</span> to manage state transitions smoothly. The game begins only once the <span>dungeon is fully generated</span> and ends either when the <span>timer runs out</span> or the <span>player leaves the start zone</span>.
<br><br>
The <span>StartGameCoroutine</span> method showcases how the GameManager waits for dungeon generation to complete before activating the game, demonstrating smooth asynchronous control flow and clear separation between setup and gameplay logic.
</p>
<pre>
<code class="language-csharp">public IEnumerator StartGameCoroutine()
{
    while (isDungeonGenerating)
    {
        yield return null;
    }

    isGameActive = true;

    if (timer != null)
    {
        timer.StartTimer();
    }

    onGameBegin.Invoke();
    Debug.Log("Game started!");
}
</code>
</pre>
<p>
My code uses a lot of <span>UnityEvents</span>, meaning that it is highly modular and event-driven, allowing different systems to communicate efficiently without tight coupling. This approach improves flexibility, makes the code easier to maintain, and enables seamless integration of new features by simply subscribing to or invoking these events.
</p><br>
<pre>
<code class="language-csharp">public IEnumerator EndGameCoroutine()
{
    if (isGameActive)
    {
        isGameActive = false;
        onGameOver.Invoke();

        Debug.Log("Game over!");

        if (generator != null && playerAtStart)
        {
            timer.ResetTimer();
            generator.ResetDungeon();

            while (isDungeonGenerating)
            {
                yield return null;
            }
        }

        else if (!playerAtStart)
        {
            SceneManager.LoadScene("FailMenu");
        }
    }
}
</code>
</pre> <br>
<h3 class="responsibilities">- Timer -</h3>
<br>
<img src="assets/timeheist/oldtimer.jpg" style="width: 1000px; border-radius: 8px;">
<p>
    The timer is a key part of the game, and is handled by its own script (<span>Timer.cs</span>). 
    <br><br>
    The <span>Timer</span> class manages a countdown timer for the game, updating a UI text element to display remaining time and changing its colour based on warning and critical thresholds. It integrates with the <span>GameManager</span> via <span>UnityEvents</span>, starting and stopping automatically when the game begins or ends, while also supporting pause, resume, and reset functionality for flexible control over timing during gameplay. 
</p>
<br><br>
<h3 class="responsibilities">- UIManager -</h3>
<br>
<p>
    The <span>UIManager</span> script is responsible for updating and managing the game's user interface elements. <br><br>
    It dynamically updates the displayed money and item count by querying the <span>MoneyManager</span> singleton, reflecting the player’s current in-game earnings and collected items. <br><br>
    Additionally, it handles scene transitions such as starting the game, returning to the menu, showing the win screen, and quitting the application.
</p>
<br><br>
<h3 class="responsibilities">- MoneyManager -</h3>
<br>
<pre>
<code class="language-csharp">private readonly HashSet&lt;GameObject&gt; collectedItems = new HashSet&lt;GameObject&gt;();

private void AddTreasureToList(GameObject item)
{
    if (item != null && collectedItems.Add(item)) 
    {
        Debug.Log($"[MoneyManager] Treasure added: {item.name}");
        UpdateValueRecovered();
        UpdateUI();
    }
}
</code>
</pre>
<p>
    The <span>MoneyManager</span> is a singleton responsible for tracking all treasure items collected by the player throughout the game. <br><br>
    It maintains a unique collection of treasures using a <code>HashSet</code> to avoid duplicates, updating the total value recovered by summing the values from each collected item’s <span>ObjectInformation</span> component. <br><br>
    The class also communicates changes to the UI by notifying the <span>UIManager</span> to update displayed money and item counts, ensuring the player’s progress is accurately reflected in real-time.
</p>
</section>
<br><br>
<section>
<h2>2.3 Item Spawning</h2>
<img src="assets/timeheist/itemspawn.png" style="width: 750px; border-radius: 8px;">
<br>
<pre>
<code class="language-csharp">private void SpawnItemAtPoint(Transform spawnPoint)
{
    if (Random.Range(0, 3) != 0)
        return;

    GameObject itemToSpawn = items[Random.Range(0, items.Count)];

    Vector3 spawnPos = spawnPoint.position + spawnOffset;
    GameObject spawnedItem = Instantiate(itemToSpawn, spawnPos, spawnPoint.rotation);

    Collider itemCollider = spawnedItem.GetComponent<Collider>();
    if (itemCollider != null)
    {
        float bottomOffset = itemCollider.bounds.min.y - spawnedItem.transform.position.y;
        Vector3 adjustedPosition = spawnPos;
        adjustedPosition.y -= bottomOffset;
        adjustedPosition += colliderBottomOffset;
        spawnedItem.transform.position = adjustedPosition;
    }

    if (spawnedItemsParent != null)
        spawnedItem.transform.SetParent(spawnedItemsParent);

    spawnedItems.Add(spawnedItem);
}
</code>
</pre>
<p>
    The <span>ItemSpawner</span> class manages the procedural placement of collectible items within the dungeon environment. <br><br>
    It identifies designated spawn points tagged as <span>ItemSpawn</span> within each generated room and attempts to spawn items at these locations with a random chance, ensuring variety and unpredictability in item placement. <br><br>
    To achieve precise positioning, the spawner calculates the vertical offset based on the item’s collider bounds, adjusting the spawn height so items rest correctly on the floor or surface, with <span>colliderBottomOffset</span>. <br><br>
    Spawned items are parented under a specified transform for organisation in the inspector, and the spawner maintains an internal list of all currently spawned items for easy management, including methods to add or remove items dynamically during gameplay. <br><br>
    The spawning process is implemented as a coroutine, allowing it to run smoothly over multiple frames without freezing the game, which is critical for maintaining <span>performance</span> in mobile Virtual Reality.
</p>
</section>
<br><br><br>
<section>
    <h1>Section 3 | Playtesting in VR</h1>
    <br>
    <p>Following the <span>Gantt Chart</span>, starting from week 4, we invited both team members and external participants to <span>playtest</span> the game. This process was crucial to gather valuable user feedback, identify potential issues early, and refine the VR experience to ensure it was stable and presentation-ready for the <a href="https://www.linkedin.com/showcase/code-and-canvas-exhibition/">Code & Canvas Exhibition</a>.</p>
    <img src="assets/timeheist/playtest.webp" style="width: 750px; border-radius: 8px;">
    <p>Playtesting allowed us to fine-tune key settings such as <span>player speed</span> and <span>level size</span>. It also uncovered bugs, including <i>holsters not tracking accurately to real-world positions</i> and <i>object damage failing in specific areas</i>, all of which were addressed in preparation for the exhibition.<br><br>
    The most significant issue revealed early on was <span>performance</span>. To tackle this, we lowered light-quality settings considerably and implemented a <span>culling</span> system that disables lights and renderers outside the player’s view, resulting in a dramatic performance boost.<br><br>
    The exhibition provided access to many playtesters, especially first-time VR users. Their feedback highlighted persistent challenges, including difficulties with depth perception and unintuitive controls, which we thoroughly documented for future improvements.</p>
</section>


<br><br><br>
<section>
    <h1>Section 4 | Reflection</h1>
    <p>
        Developing <span>Time Heist</span> was an intensive and highly practical learning experience. It was our first serious attempt at creating a complete VR game, and we approached it with a clear focus: to build something playable, stable, and presentable within the project timeframe. From the earliest stages of planning through to exhibition day, our team made consistent progress. 
        <br><br>
        The project culminated at the <a href="https://www.linkedin.com/showcase/code-and-canvas-exhibition/">Code & Canvas Exhibition</a>, where we had the opportunity to share the game with the public and industry professionals, and receive direct feedback from a wide variety of players — including those who had never used VR before. We were proud to receive the <strong>Team Choice (1st Years)</strong> award, which showed that our peers and others recognised the work and ambition behind the project. 
    </p>
    <br>
    <h3>Technical and Design Reflections</h3>
    <br>
    <p>
        Designing for VR is not as intuitive as designing for flatscreen 3D. Early in development, we realised how much needed to be reconsidered: UI, player input, interaction techniques, and even basic navigation all behave differently in VR. Some of our initial ideas had to be scrapped or redesigned when we saw how unintuitive they felt in practice. In particular, there were frequent issues around object interaction — grabbing, dropping, and holstering — that required multiple attempts to feel somewhat intuitive.
        <br><br>
        One of the most difficult aspects of the project was managing performance. VR demands stable, high frame rates, and the mobile headset we were targeting had very limited resources.
        <br><br>
        Beyond technical issues, playtesting revealed gaps in our UX. For many users, especially those unfamiliar with VR, depth perception was difficult — making it harder to judge distances and interact with objects precisely. These challenges made it clear how crucial accessibility and intuitiveness are in VR design, especially for onboarding new players.
    </p>
    <br>
    <h3>Teamwork, Communication, and Scope</h3>
    <br>
    <p>
        As a whole, the entire team worked great together, and it was by far the most enjoyable team experience yet. We communicated often and well - with a mix of in-person and online meetings, and, overall we understood exactly what was expected of us. There were of course some issues, however nothing disastrous.
        <br><br>
        One of the more subtle lessons was around scope control. Our original ideas for <span>Time Heist</span> included puzzles, a proper tutorial, and additional gameplay systems such as time-based challenges. We had to cut or simplify many of these features to stay within the project timeline. In future projects, we’ll be more deliberate about breaking down features into modular, testable systems from the beginning.
    </p>
    <br>
    <h3>Further Development</h3>
    <br>
    <p>
        Despite some technical compromises, <span>Time Heist</span> reached a solid level of functionality and polish, particularly for our first VR project. It gave us a working foundation that we could feasibly expand upon, as well as a clear understanding of what it takes to build and deliver an interactive VR experience.
    </p>
    <br>
    <p>
        Given another 4 to 6 weeks, we could refine some of the systems that currently feel rigid or incomplete — such as improving the responsiveness of object interactions and creating a clearer onboarding process for new players. A couple more weeks on top of that would likely be necessary to bring the overall polish up to a more professional standard. This would include sound design, UI animation, environmental effects, and better visual or audio feedback for player actions.
    </p>
    <br>
    <p>This project also highlighted several areas I’d like to explore further in future work:</p>
    <br>
    <ul>
        <li>> UX and interaction design specifically for VR, especially with first-time users in mind</li>
        <li>> Mobile performance profiling and memory management in Unity</li>
        <li>> System architecture planning to reduce unnecessary complexity and improve modularity</li>
    </ul>
    <br>
    <p>
        These skills would directly benefit any future projects I take on, particularly those in VR or AR, where performance and user interaction are especially critical.
    </p>
    <br>
    <p>
        Overall, <span>Time Heist</span> has laid a strong foundation for me as a developer. It exceeded my expectations and demonstrated what our team is capable of. I'm proud of what we presented at the exhibition — especially winning the <strong>Team Choice (1st Years)</strong> award — and excited to build on this momentum in future projects.
    </p>
</section>



<br>
<img src="assets/catsandfrogs/GameDemoFull.gif" alt="Final Demo" style="width: 500px; border-radius: 8px; margin: 20px 0;">
<br>

<section>
<h2>1.6 Further Development</h2>
<p>Following my reflection, I have outlined a plan that I could follow to rework the game from the ground up:</p>
<pre style="background: #1e293b; padding: 20px; border-radius: 8px; margin: 40px 0; white-space: pre-wrap;">
    <b>Sprint 1:</b>
    -	Strip game down to its core mechanics, preserving best-performing scripts
    -   Replace Touch Handling with a more optimised premade asset
    -   Redesign and rewrite grid system for performance
    -   Rewrite placement system to make more intuitive
    <b>Sprint 2:</b>
    -	Using the new grid and placement, rewrite the shop spawning to be controlled by a single manager
    -   Rework player and Enemy Controllers
    -   Rewrite attack system
    <b>Sprint 3:</b>
    -	Polish up previous scripts
    -   Create all new types of entities
    -   Polish UI
</pre>
</section>

<br>

<section>
<h2>1.7 Key Tasks & Dependencies</h2>
<pre style="background: #1e293b; padding: 20px; border-radius: 8px; margin: 40px 0; white-space: pre-wrap;">
<b>Art: </b>Must be completed before main menu & UI can be polished, before sprite animations can be finalised, and before background elements can be added.
<br>
<b>Shop System: </b>Must be entirely reworked before expanding scope, as it is very hard to build upon right now.
<br>
<b>Animations: </b>I could not get sprite animations working correctly, this needs to be fixed before the game can be considered polished.
</pre>
</section>

<br>

<section class="references" id="references">
    <h3>References</h3>
    <br>
    <p>[1.2.1] How to Make a Pixel Art Frog (2023). [Art]. Go Real Games, LLC. Retrieved from <a href="https://www.megavoxels.com/learn/how-to-make-a-pixel-art-frog/">https://www.megavoxels.com/learn/how-to-make-a-pixel-art-frog/</a></p>
    <br>
    <p>[1.2.2] Pixel Art Top Down - Basic. [Art]. Cainos. Retrieved from <a href="https://cainos.itch.io/pixel-art-top-down-basic">https://cainos.itch.io/pixel-art-top-down-basic/</a></p>
    <br>
    <p>[1.2.4] This is Pixel Art 32 (2024). [Art]. The_PixelPrysm. Retrieved from <a href="https://www.reddit.com/r/PixelArt/comments/1aprcl3/this_is_pixel_art_32/">https://www.reddit.com/r/PixelArt/comments/1aprcl3/this_is_pixel_art_32/</a></p>
    <br>
</section>

</article>
</main>
</body>
</html>